<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:," />
  <title>Level 1: Tutorial</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #87CEEB;
    }
  
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    #death-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      color: white;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 1000;
      gap: 20px;
      box-sizing: border-box;
      padding: 40px;
    }

    #death-screen h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      color: #FF6347; /* Tomato red */
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.6);
    }
  
    #death-message {
      font-size: 1.8rem;
      margin-bottom: 30px;
      font-family: "Arial", sans-serif;
    }
  
    #death-screen button {
      background-color: #FF6347;
      color: white;
      padding: 15px 40px;
      font-size: 1.5rem;
      border: none;
      cursor: pointer;
      margin-top: 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(255, 99, 71, 0.8);
      transition: transform 0.3s, box-shadow 0.3s;
    }
  
    #death-screen button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 99, 71, 1);
    }
  
    #death-screen button:active {
      transform: scale(1.05);
    }
  
    /* Fade-in animation for the death screen */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .tutorial-text {
      position: absolute;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      pointer-events: none;
      max-width: 200px;
      text-align: center;
      z-index: 10;
      font-family: Arial, sans-serif;
    }

    .controls-text {
      z-index: 100;
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
      font-size: 16px;
      font-family: Arial, sans-serif;
  width: 490px; /* Fixed width */
  height: 20px; /* Let height adjust to content */
  white-space: nowrap; /* Prevent text wrapping */
    }

    #toggle-tutorials {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: Arial, sans-serif;
      z-index: 100;
    }

    #toggle-tutorials:hover {
      background: rgba(0, 0, 0, 0.9);
    }

    .barrel-emoji {
  position: absolute;
  font-size: 24px;
  pointer-events: none;
  z-index: 10;
  transform: translate(-50%, -50%);
}
  </style>
  
</head>
<body>
  <div id="death-screen">
    <h2>Game Over!</h2>
    <p id="death-message"></p>
    <button onclick="restartGame()">Retry</button>
  </div>

    <!-- Tutorial Text Elements -->
    <div class="tutorial-text" id="button-tutorial" style="display: none;">
      BUTTON: Opens the exit (for player and interactive blocks)
    </div>
    <div class="tutorial-text" id="bbc-tutorial" style="display: none;">
      BBC: Gives random power-ups
    </div>
    <div class="tutorial-text" id="platform-tutorial" style="display: none;">
      MOVING PLATFORM: Stand on it to ride
    </div>
    <div class="tutorial-text" id="cop-tutorial" style="display: none;">
      COP: Chase and kills you
    </div>
    <div class="tutorial-text" id="blocks-tutorial" style="display: none;">
      INTERACTIVE BLOCKS: Can be used to activate button
    </div>
    <div class="tutorial-text" id="spikes-tutorial" style="display: none;">
      DEADLY SPIKES: Kills you
    </div>
    <div class="tutorial-text" id="exit-tutorial" style="display: none;">
      EXIT DOOR: To go the next level
    </div>
  
    <div class="controls-text">
      CONTROLS: Arrow Keys or WAD to move (Double Jump available)
    </div>
    
  <button id="toggle-tutorials">Hide Tutorials</button>
  <div id="barrel-emoji" class="barrel-emoji">ðŸ’€</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>

  <script>
    const { Engine, Render, World, Bodies, Body, Events } = Matter;
    const engine = Engine.create();
    const world = engine.world;
    let gameOver = false;

    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "#87CEEB",
      }
    });

    // Preload player sprites
    const idle1 = new Image();
    const idle2 = new Image();
    const walk1 = new Image();
    const walk2 = new Image();
    const jumpp = new Image();
    const fall = new Image();

    idle1.src = "images/idle1.png";
    idle2.src = "images/idle2.png";
    walk1.src = "images/walk1.png";
    walk2.src = "images/walk2.png";
    jumpp.src = "images/jumpp.png";
    fall.src = "images/fall.png";

    // Preload cop image
    const copImage = new Image();
    copImage.src = "images/cop.png";
    copImage.onload = () => console.log("cop.png loaded");
    copImage.onerror = () => console.error("Failed to load cop.png");

    // Preload BBC image
    const bbcImage = new Image();
    bbcImage.src = "images/bbc.png";
    bbcImage.onload = () => console.log("bbc.png loaded");
    bbcImage.onerror = () => console.error("Failed to load bbc.png");

    window.addEventListener('resize', () => {
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      Render.setSize(render, window.innerWidth, window.innerHeight);
    });

    let timeLeft = 60;

    let timerDisplay = document.createElement("div");
    timerDisplay.style.position = "absolute";
    timerDisplay.style.top = "10px";
    timerDisplay.style.left = "10px";
    timerDisplay.style.fontSize = "24px";
    timerDisplay.style.fontFamily = "Arial";
    timerDisplay.style.color = "white";
    timerDisplay.innerHTML = `Time: ${timeLeft}s`;
    document.body.appendChild(timerDisplay);

    let powerUpText = document.createElement("div");
    powerUpText.style.position = "absolute";
    powerUpText.style.top = "50px";
    powerUpText.style.left = "10px";
    powerUpText.style.fontSize = "20px";
    powerUpText.style.fontFamily = "Arial";
    powerUpText.style.color = "yellow";
    powerUpText.style.fontWeight = "bold";
    powerUpText.style.display = "none";
    document.body.appendChild(powerUpText);

    let forcefieldTimerText = document.createElement("div");
    forcefieldTimerText.style.position = "absolute";
    forcefieldTimerText.style.top = "80px";
    forcefieldTimerText.style.left = "10px";
    forcefieldTimerText.style.fontSize = "20px";
    forcefieldTimerText.style.fontFamily = "Arial";
    forcefieldTimerText.style.color = "cyan";
    forcefieldTimerText.style.fontWeight = "bold";
    forcefieldTimerText.style.display = "none";
    document.body.appendChild(forcefieldTimerText);

    let deathScreen = document.getElementById("death-screen");
    let deathMessage = document.getElementById("death-message");

    function showDeathScreen(message) {
      if (gameOver) return;

      gameOver = true;
      deathMessage.innerHTML = message;
      deathScreen.style.display = "flex";
      clearInterval(countdown);
      Engine.clear(engine);
      render.canvas.remove();
      render.textures = {};
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
    }

    function restartGame() {
      location.reload();
    }

    const player = Bodies.rectangle(200, window.innerHeight - 50, 50, 50, {
      restitution: 0.2,
      friction: 0.8,
      density: 0.01,
      inertia: Infinity,
      isInvincible: false, // Added for forcefield
      render: { fillStyle: "transparent" } // Make the Matter.js body invisible
    });

    const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 20, window.innerWidth, 40, { isStatic: true });
    const platform = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 200, 300, 20, { isStatic: true });
    const spikes = Bodies.rectangle(window.innerWidth / 2 - 200, window.innerHeight - 50, 100, 20, {
      isStatic: true,
      render: { fillStyle: "transparent" }
    });

    const fastMovingPlatform = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 400, 200, 20, {
      isStatic: true,
      render: { fillStyle: "orange" }
    });

    const barrel = Bodies.circle(window.innerWidth / 2 + 100, window.innerHeight - 40, 30, {
      isStatic: false,
      restitution: 0.6,
      render: { fillStyle: "red" }
    });

    const exitDoor = Bodies.rectangle(window.innerWidth - 50, window.innerHeight - 100, 50, 100, {
      isStatic: true,
      render: { fillStyle: "green" }
    });

    const exitBlocker = Bodies.rectangle(window.innerWidth - 75, window.innerHeight - 150, 100, 200, {
      isStatic: true,
      render: { fillStyle: "#444" }
    });

    const bbc = Bodies.circle(200, window.innerHeight - 300, 20, {
      isStatic: true,
      isSensor: true,
      render: { fillStyle: "yellow" } // Make the BBC circle invisible (we'll draw the image instead)
    });

    let bbcActivated = false;
    let forcefieldParticles = []; // Array for forcefield particles

    let playerState = "idle"; // Possible states: "idle", "walking", "jumping", "falling"
    let currentSprite = idle1; // Default sprite
    let animationTimer = 0; // Timer for sprite animation

    function giveRandomPowerUp() {
      const powerUps = ["extraJump", "forcefield", "extraTime"];
      const chosen = powerUps[Math.floor(Math.random() * powerUps.length)];

      switch (chosen) {
        case "extraJump":
          powerUpText.innerText = "Power-Up: Extra Jump!";
          powerUpText.style.display = "block";
          maxJumpCount = 3;  // triple jump
          break;

        case "forcefield":
          powerUpText.innerText = "Power-Up: Forcefield!";
          powerUpText.style.display = "block";
          player.isInvincible = true;

          // Create forcefield particles
          forcefieldParticles = [];
          for (let i = 0; i < 20; i++) {
            forcefieldParticles.push({
              angle: Math.random() * Math.PI * 2,
              distance: 35 + Math.random() * 10,
              speed: 0.05 + Math.random() * 0.1
            });
          }

          let forcefieldDuration = 8; // seconds
          forcefieldTimerText.style.display = "block";
          forcefieldTimerText.innerText = `Forcefield: ${forcefieldDuration}s`;

          const intervalId = setInterval(() => {
            forcefieldDuration--;
            forcefieldTimerText.innerText = `Forcefield: ${forcefieldDuration}s`;

            if (forcefieldDuration <= 0) {
              clearInterval(intervalId);
              player.isInvincible = false;
              forcefieldTimerText.style.display = "none";
              forcefieldParticles = []; // Clear particles
            }
          }, 1000);
          break;

        case "extraTime":
          powerUpText.innerText = "Power-Up: Extra Time!";
          powerUpText.style.display = "block";
          timeLeft += 20;
          break;
      }

      // Hide the message after a while
      setTimeout(() => {
        powerUpText.style.display = "none";
      }, 4000);
    }

    const buttonX = 100;
    const buttonBaseY = window.innerHeight - 40;
    const buttonTopY = buttonBaseY - 15;

    const buttonTop = Bodies.rectangle(buttonX, buttonTopY, 40, 10, {
      isStatic: true,
      render: { fillStyle: "red", zIndex: 1 }
    });

    const buttonBase = Bodies.rectangle(buttonX, buttonBaseY, 60, 20, {
      isStatic: true,
      render: { fillStyle: "gray", zIndex: 2 }
    });

    const box1 = Bodies.circle(300, 200, 30, {
      restitution: 0.8,
      render: { fillStyle: "lime" }
    });

    const box2 = Bodies.polygon(500, 150, 3, 40, {
      restitution: 0.6,
      render: { fillStyle: "lime" }
    });

    const box3 = Bodies.rectangle(800, 100, 60, 60, {
      restitution: 0.4,
      render: { fillStyle: "lime" }
    });

    const interactiveBlocks = [box1, box2, box3];

    // Create cop NPC with transparent body (we'll draw the image instead)
    const cop = Bodies.rectangle(window.innerWidth / 2 + 300, window.innerHeight - 180, 80, 100, {
      friction: 0.9,
      inertia: Infinity,
      render: { fillStyle: "transparent" } // Make the Matter.js body invisible
    });
    World.add(world, cop);

    World.add(world, [
      player, ground, platform, spikes, barrel,
      exitDoor, exitBlocker, bbc, buttonTop, buttonBase, fastMovingPlatform,
      ...interactiveBlocks
    ]);

    function showTutorialTexts() {
      if (!tutorialsVisible) return;
      
      // Position and show all tutorial texts
      positionTutorialText('button-tutorial', buttonTop.position.x, buttonTop.position.y - 40);
      positionTutorialText('bbc-tutorial', bbc.position.x, bbc.position.y - 40);
      positionTutorialText('platform-tutorial', fastMovingPlatform.position.x, fastMovingPlatform.position.y - 40);
      positionTutorialText('cop-tutorial', cop.position.x, cop.position.y - 120);
      positionTutorialText('blocks-tutorial', box1.position.x, box1.position.y - 60);
      positionTutorialText('spikes-tutorial', spikes.position.x, spikes.position.y - 40);
      positionTutorialText('exit-tutorial', exitDoor.position.x, exitDoor.position.y - 120);
    }

    function positionTutorialText(id, x, y) {
      const element = document.getElementById(id);
      element.style.left = `${x - element.offsetWidth/2}px`;
      element.style.top = `${y}px`;
      element.style.display = 'block';
    }

    setTimeout(showTutorialTexts, 1000);

    let tutorialsVisible = true;

    const toggleTutorialsBtn = document.getElementById('toggle-tutorials');
    toggleTutorialsBtn.addEventListener('click', () => {
      tutorialsVisible = !tutorialsVisible;
      
      // Get all tutorial text elements
      const tutorialTexts = document.querySelectorAll('.tutorial-text');
      
      // Toggle their visibility
      tutorialTexts.forEach(text => {
        text.style.display = tutorialsVisible ? 'block' : 'none';
      });
      
      // Update button text
      toggleTutorialsBtn.textContent = tutorialsVisible ? 'Hide Tutorials' : 'Show Tutorials';
      
      // If showing tutorials, update their positions
      if (tutorialsVisible) {
        showTutorialTexts();
      }
    });

    let buttonPressCooldown = false;
    let buttonPressed = false;
    let keys = {};
    let jumpCount = 0;
    let lastSafePosition = { x: player.position.x, y: player.position.y };
    let isTeleporting = false;
    const safeSurfaces = [ground];

    let maxJumpCount = 2;

    Engine.run(engine);
    Render.run(render);

    // Custom render function to draw the player sprite
    Events.on(render, "afterRender", () => {
      const ctx = render.context;
      
      // Draw spikes as grey triangles
      ctx.save();
      const spikeWidth = 100; // Total width of the spike group
      const spikeHeight = 20; // Height of each spike
      const spikeCount = 5; // Number of triangles
      const spikeX = spikes.position.x - spikeWidth / 2; // Start position (centered)
      const spikeY = spikes.position.y - spikeHeight / 2;

      ctx.fillStyle = "grey"; // Grey color for spikes
      ctx.beginPath();

      for (let i = 0; i < spikeCount; i++) {
        const x = spikeX + (i * spikeWidth) / spikeCount;
        const xMid = x + spikeWidth / (2 * spikeCount);
        const xEnd = x + spikeWidth / spikeCount;

        // Draw a triangle
        ctx.moveTo(x, spikeY + spikeHeight); // Bottom-left corner
        ctx.lineTo(xMid, spikeY); // Top point
        ctx.lineTo(xEnd, spikeY + spikeHeight); // Bottom-right corner
      }

      ctx.fill(); // Fill the triangles with grey
      ctx.restore();

      // Draw the player's sprite
      ctx.save();
      const playerPos = player.position;

      ctx.translate(playerPos.x, playerPos.y);
      if (player.velocity.x < 0) {
        ctx.scale(-1, 1); // Flip horizontally if moving left
      }
      ctx.drawImage(currentSprite, -25, -25, 50, 50); // Adjust size to match player dimensions
      ctx.restore();

      // Draw the BBC image if it's not activated
      if (!bbcActivated && bbcImage.complete && bbcImage.naturalWidth !== 0) {
        ctx.save();
        ctx.translate(bbc.position.x, bbc.position.y);
        ctx.drawImage(bbcImage, -20, -20, 40, 40); // Adjust size to match the BBC radius (20)
        ctx.restore();
      }

      // Draw the cop image
      if (copImage.complete && copImage.naturalWidth !== 0) {
        ctx.save();
        ctx.translate(cop.position.x, cop.position.y);
        // Flip cop based on movement direction
        if (cop.velocity.x < 0) {
          ctx.scale(-1, 1); // Flip horizontally if moving left
        }
        const copBodyWidth = 180; // Match the width of the cop's Matter.js body
        ctx.drawImage(
          copImage,
          -copBodyWidth / 2, // Center horizontally
          -50,               // Offset vertically (unchanged)
          copBodyWidth,      // Match the block width
          100                // Height remains unchanged
        );
        ctx.restore();
      }

      // Draw forcefield if active
      if (player.isInvincible) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.6;
        ctx.arc(player.position.x, player.position.y, 35, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Forcefield particle effect
        if (forcefieldParticles.length > 0) {
          ctx.save();
          forcefieldParticles.forEach(p => {
            p.angle += p.speed;
            const x = player.position.x + Math.cos(p.angle) * p.distance;
            const y = player.position.y + Math.sin(p.angle) * p.distance;
            
            ctx.beginPath();
            ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.restore();
        }
        ctx.restore();
      }
    });

    let countdown = setInterval(() => {
      timeLeft--;
      timerDisplay.innerHTML = `Time: ${timeLeft}s`;
      if (timeLeft <= 0) {
        clearInterval(countdown);
        showDeathScreen("Game Over! Time Ran Out!");
      }
    }, 1000);

    function handleKeyDown(e) {
      keys[e.code] = true;
      if ((e.code === "ArrowUp" || e.code === "KeyW") && jumpCount < maxJumpCount) {
        Body.setVelocity(player, { x: player.velocity.x, y: -10 });
        jumpCount++;
      }
    }

    function handleKeyUp(e) {
      keys[e.code] = false;
    }

    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    let copCanJump = true;

    let fastMovingPlatformSpeed = 3;
    let movingRight = true;

    Events.on(engine, "beforeUpdate", () => {
      // Update barrel emoji position
      const barrelEmoji = document.getElementById('barrel-emoji');
      if (barrelEmoji) {
        barrelEmoji.style.left = `${barrel.position.x}px`;
        barrelEmoji.style.top = `${barrel.position.y}px`;
      }
      // Update player state
      if (player.velocity.y > 1) {
        playerState = "falling";
      } else if (player.velocity.y < -1) {
        playerState = "jumping";
      } else if (Math.abs(player.velocity.x) > 0.1) {
        playerState = "walking";
      } else {
        playerState = "idle";
      }

      // Update sprite based on player state
      if (playerState === "idle") {
        animationTimer += 0.016; // Increment timer (assuming 60 FPS)
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === idle1 ? idle2 : idle1;
          animationTimer = 0;
        }
      } else if (playerState === "walking") {
        animationTimer += 0.016;
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === walk1 ? walk2 : walk1;
          animationTimer = 0;
        }
      } else if (playerState === "jumping") {
        currentSprite = jumpp;
      } else if (playerState === "falling") {
        currentSprite = fall;
      }

      function positionPlayerTutorialText() {
        const playerTutorial = document.querySelector('.controls-text');
        if (playerTutorial && tutorialsVisible) {
          // Position the tutorial text relative to the player's current position
          playerTutorial.style.left = `${player.position.x - playerTutorial.offsetWidth / 2}px`;
          playerTutorial.style.top = `${player.position.y - 100}px`; // Adjust the vertical offset as needed
          playerTutorial.style.display = 'block';
        } else {
          playerTutorial.style.display = 'none';
        }
      }

      positionPlayerTutorialText();

      // Update tutorial text positions
      if (tutorialsVisible) {
        if (document.getElementById('button-tutorial').style.display !== 'none') {
          positionTutorialText('button-tutorial', buttonTop.position.x, buttonTop.position.y - 40);
        }
        if (!bbcActivated && document.getElementById('bbc-tutorial').style.display !== 'none') {
          positionTutorialText('bbc-tutorial', bbc.position.x, bbc.position.y - 40);
        }
        positionTutorialText('platform-tutorial', fastMovingPlatform.position.x, fastMovingPlatform.position.y - 40);
        positionTutorialText('cop-tutorial', cop.position.x, cop.position.y - 120);
        positionTutorialText('blocks-tutorial', box1.position.x, box1.position.y - 60);
        positionTutorialText('spikes-tutorial', spikes.position.x, spikes.position.y - 40);
        positionTutorialText('exit-tutorial', exitDoor.position.x, exitDoor.position.y - 120);
      }

      if (!bbcActivated && isOverlapping(player, bbc)) {
        bbcActivated = true;
        giveRandomPowerUp();
        World.remove(world, bbc); // remove so it can't trigger again
      }

      if (keys["ArrowLeft"] || keys["KeyA"]) {
        Body.setVelocity(player, { x: -5, y: player.velocity.y });
      }
      if (keys["ArrowRight"] || keys["KeyD"]) {
        Body.setVelocity(player, { x: 5, y: player.velocity.y });
      }

      Body.setAngle(player, 0);

      if (!isTeleporting && player.position.y > window.innerHeight + 100) {
        isTeleporting = true;
        setTimeout(() => {
          Body.setPosition(player, lastSafePosition);
          Body.setVelocity(player, { x: 0, y: 0 });
          isTeleporting = false;
        }, 200);
      }

      // Define platform bounds
      const leftBound = 250;
      const rightBound = window.innerWidth - 250;

      // Change direction at bounds
      if (fastMovingPlatform.position.x >= rightBound) {
        movingRight = false;
      }
      if (fastMovingPlatform.position.x <= leftBound) {
        movingRight = true;
      }

      // Move platform
      const moveAmount = movingRight ? fastMovingPlatformSpeed : -fastMovingPlatformSpeed;
      Body.translate(fastMovingPlatform, { x: moveAmount, y: 0 });

      // Move player if standing on platform
      const playerBottom = player.position.y + 25;
      const platformTop = fastMovingPlatform.position.y - 10;

      const isOnPlatform =
        Math.abs(playerBottom - platformTop) < 8 &&
        Math.abs(player.position.x - fastMovingPlatform.position.x) < 100 &&
        Math.abs(player.velocity.y) < 1;

      if (isOnPlatform) {
        Body.translate(player, { x: moveAmount, y: 0 });
      }

      // --- COP CHASING LOGIC ---
      const distX = player.position.x - cop.position.x;
      const distY = player.position.y - cop.position.y;
      const direction = Math.sign(distX);
      const copSpeed = 1.5;

      Body.setVelocity(cop, { x: direction * copSpeed, y: cop.velocity.y });

      // Cop jump logic (ensure it jumps only when required)
      const jumpNeeded = distY < -60 || distY > 100;
      if (jumpNeeded && copCanJump) {
        Body.setVelocity(cop, { x: cop.velocity.x, y: -10 });
        copCanJump = false;  // Prevent further jumps until landing
      }

      // Cop landing detection
      const copBottom = cop.position.y + cop.bounds.max.y - cop.position.y;
      const copPlatforms = [ground, platform, fastMovingPlatform];  // Add the relevant platforms

      copPlatforms.forEach((platform) => {
        if (
          Math.abs(copBottom - platform.position.y) < 5 &&
          Math.abs(cop.position.x - platform.position.x) < (platform.bounds.max.x - platform.bounds.min.x) / 2
        ) {
          copCanJump = true;  // Allow cop to jump again when it lands
        }
      });

      // Check for game over if player is close
      if (isOverlapping(player, cop)) {
        if (!player.isInvincible)
          showDeathScreen("The cop caught you!");
      }

      // Inside your "beforeUpdate" event listener:
      const touchingButton = interactiveBlocks.some(block =>
        isOverlapping(block, buttonTop)
      ) || isOverlapping(player, buttonTop);

      if (touchingButton && !buttonPressed && !buttonPressCooldown) {
        buttonPressed = true;
        buttonPressCooldown = true;

        Body.setPosition(buttonTop, {
          x: buttonTop.position.x,
          y: buttonBase.position.y - 1
        });

        World.remove(world, exitBlocker);

        setTimeout(() => {
          buttonPressCooldown = false;
        }, 500);
      }
    });

    function isInteractiveBlock(body) {
      return interactiveBlocks.some(block => block.id === body.id);
    }

    function isOverlapping(bodyA, bodyB) {
      return !(
        bodyA.bounds.max.x < bodyB.bounds.min.x ||
        bodyA.bounds.min.x > bodyB.bounds.max.x ||
        bodyA.bounds.max.y < bodyB.bounds.min.y ||
        bodyA.bounds.min.y > bodyB.bounds.max.y
      );
    }

    Events.on(engine, "collisionStart", (event) => {
      if (gameOver) return;

      event.pairs.forEach((pair) => {
        const bodies = [pair.bodyA, pair.bodyB];

        if (bodies.includes(player)) {
          if (
            bodies.includes(ground) ||
            bodies.includes(platform) ||
            bodies.includes(buttonBase) ||
            bodies.includes(buttonTop) ||
            bodies.includes(fastMovingPlatform)
          ) {
            jumpCount = 0;
          }

          if (bodies.includes(spikes)) {
            if (!player.isInvincible)
              showDeathScreen("You hit the spikes!");
          }

          if (bodies.includes(barrel)) {
            if (!player.isInvincible)
              showDeathScreen("You were hit by the barrel!");
          }

          if (bodies.includes(exitDoor)) {
            window.location.href = "level2.html";
          }

          if (safeSurfaces.includes(pair.bodyA) || safeSurfaces.includes(pair.bodyB)) {
            lastSafePosition = { x: player.position.x, y: player.position.y };
          }

          const isButtonHit =
            (bodies.includes(buttonTop) || bodies.includes(buttonBase)) &&
            (bodies.includes(player) || isInteractiveBlock(pair.bodyA) || isInteractiveBlock(pair.bodyB));

          if (isButtonHit && !buttonPressed && !buttonPressCooldown) {
            buttonPressed = true;
            buttonPressCooldown = true;

            Body.setPosition(buttonTop, {
              x: buttonTop.position.x,
              y: buttonBase.position.y - 8
            });

            World.remove(world, exitBlocker);

            setTimeout(() => {
              buttonPressCooldown = false;
            }, 500);
          }
        }
      });
    });

    const particles = [];

    (function renderParticles() {
      requestAnimationFrame(renderParticles);
      const ctx = render.context;
      ctx.save();
      particles.forEach(p => {
        ctx.beginPath();
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = "white";
        ctx.arc(p.x, p.y, p.radius, 0, 2 * Math.PI);
        ctx.fill();
      });
      ctx.restore();
    })();
  </script>
</body>
</html>