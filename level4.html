<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Level 4: Village</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: url('images/village.jpg') no-repeat center center fixed;
      background-size: cover;
      height: 100vh;
    }

    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
    }

    #death-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 1000;
      gap: 20px;
      box-sizing: border-box;
      padding: 40px;
    }

    #death-screen h2 {
      font-size: 3rem;
      margin-bottom: 20px;
      color: #FF6347;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.6);
    }
  
    #death-message {
      font-size: 1.8rem;
      margin-bottom: 30px;
      font-family: "Arial", sans-serif;
    }
  
    #death-screen button {
      background-color: #FF6347;
      color: white;
      padding: 15px 40px;
      font-size: 1.5rem;
      border: none;
      cursor: pointer;
      margin-top: 20px;
      border-radius: 12px;
      box-shadow: 0 0 10px rgba(255, 99, 71, 0.8);
      transition: transform 0.3s, box-shadow 0.3s;
    }
  
    #death-screen button:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 99, 71, 1);
    }
  
    #death-screen button:active {
      transform: scale(1.05);
    }

    .game-ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial;
    }
    
    #timer {
      font-size: 24px;
    }
    
    #powerup-text {
      font-size: 20px;
      color: yellow;
      font-weight: bold;
      display: none;
    }
    
    #forcefield-timer {
      font-size: 20px;
      color: cyan;
      font-weight: bold;
      display: none;
    }

.barrel-emoji {
position: absolute;
font-size: 24px;
pointer-events: none;
z-index: 10;
transform: translate(-50%, -50%);
}
  </style>
</head>
<body>
  <div id="death-screen">
    <h2>Game Over!</h2>
    <p id="death-message"></p>
    <button onclick="restartGame()">Retry</button>
  </div>

  <div class="game-ui">
    <div id="timer">Time: 60s</div>
    <div id="powerup-text"></div>
    <div id="forcefield-timer"></div>
  </div>

  <div id="barrel-emoji" class="barrel-emoji">ðŸ’€</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
  <script>
    const { Engine, Render, World, Bodies, Body, Events } = Matter;
    const engine = Engine.create();
    const world = engine.world;
    let gameOver = false;
    let forcefieldParticles = [];

    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "transparent",
      }
    });

    // Preload player sprites
    const idle1 = new Image();
    const idle2 = new Image();
    const walk1 = new Image();
    const walk2 = new Image();
    const jumpp = new Image();
    const fall = new Image();

    idle1.src = "images/idle1.png";
    idle2.src = "images/idle2.png";
    walk1.src = "images/walk1.png";
    walk2.src = "images/walk2.png";
    jumpp.src = "images/jumpp.png";
    fall.src = "images/fall.png";

    // Preload cop image
    const copImage = new Image();
    copImage.src = "images/cop.png";
    copImage.onload = () => console.log("cop.png loaded");
    copImage.onerror = () => console.error("Failed to load cop.png");

    // Preload BBC image
    const bbcImage = new Image();
    bbcImage.src = "images/bbc.png";
    bbcImage.onload = () => console.log("BBC image loaded successfully");
    bbcImage.onerror = () => console.error("Failed to load BBC image");

    window.addEventListener('resize', () => {
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      Render.setSize(render, window.innerWidth, window.innerHeight);
    });

    let timeLeft = 60;
    let timerDisplay = document.getElementById("timer");
    let powerUpText = document.getElementById("powerup-text");
    let forcefieldTimer = document.getElementById("forcefield-timer");
    let deathScreen = document.getElementById("death-screen");
    let deathMessage = document.getElementById("death-message");

    function showDeathScreen(message) {
      if (gameOver) return;
      gameOver = true;
      deathMessage.innerHTML = message;
      deathScreen.style.display = "flex";
      clearInterval(countdown);
    }

    function restartGame() {
      location.reload();
    }

    const player = Bodies.rectangle(200, window.innerHeight - 50, 50, 50, {
      restitution: 0.2,
      friction: 0.8,
      density: 0.01,
      inertia: Infinity,
      isInvincible: false,
      render: { fillStyle: "transparent" }
    });

    const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 20, window.innerWidth, 40, { 
      isStatic: true,
      render: { fillStyle: "#2a2a2a" }
    });

    const platform = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 200, 300, 20, { 
      isStatic: true,
      render: { fillStyle: "#5a5a5a" }
    });

    const spikes = Bodies.rectangle(window.innerWidth / 2 - 200, window.innerHeight - 50, 100, 20, {
      isStatic: true,
      render: { fillStyle: "transparent" }
    });

    const fastMovingPlatform = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 400, 200, 20, {
      isStatic: true,
      render: { fillStyle: "orange" }
    });

    const barrel = Bodies.circle(window.innerWidth / 2 + 100, window.innerHeight - 40, 30, {
      isStatic: false,
      restitution: 0.6,
      render: { fillStyle: "red" }
    });

    const exitDoor = Bodies.rectangle(window.innerWidth - 50, window.innerHeight - 100, 50, 100, {
      isStatic: true,
      render: { fillStyle: "green" }
    });

    const exitBlocker = Bodies.rectangle(window.innerWidth - 75, window.innerHeight - 150, 100, 200, {
      isStatic: true,
      render: { fillStyle: "#444" }
    });

    const bbc = Bodies.circle(200, window.innerHeight - 300, 20, {
      isStatic: true,
      isSensor: true,
      render: { fillStyle: "yellow" }
    });

    let bbcActivated = false;
    let playerState = "idle";
    let currentSprite = idle1;
    let animationTimer = 0;
    let maxJumpCount = 2;

    // Button system
    const buttonX = 100;
    const buttonBaseY = window.innerHeight - 40;
    const buttonTop = Bodies.rectangle(buttonX, buttonBaseY - 20, 40, 20, {
      isStatic: true,
      isSendor: true,
      render: { fillStyle: "red" }
    });
    const buttonBase = Bodies.rectangle(buttonX, buttonBaseY, 60, 20, {
      isStatic: true,
      isSendor: true,
      render: { fillStyle: "gray" }
    });

    // Interactive blocks
    const box1 = Bodies.circle(300, 200, 30, {
      restitution: 0.8,
      render: { fillStyle: "lime" }
    });
    const box2 = Bodies.polygon(500, 150, 3, 40, {
      restitution: 0.6,
      render: { fillStyle: "lime" }
    });
    const box3 = Bodies.rectangle(800, 100, 60, 60, {
      restitution: 0.4,
      render: { fillStyle: "lime" }
    });
    const interactiveBlocks = [box1, box2, box3];

    // Guard system
    const guardedPlatform = Bodies.rectangle(window.innerWidth - 250, 150, 500, 20, {
      isStatic: true,
      render: { fillStyle: "#5a5a5a" }
    });
    const guardingCop = Bodies.rectangle(window.innerWidth - 150, 100, 60, 100, {
      friction: 0.9,
      inertia: Infinity,
      render: { fillStyle: "transparent" },
      label: "guardingCop"
    });
    const guardedButtonTop = Bodies.rectangle(window.innerWidth - 80, 115, 40, 20, {
      isStatic: true,
      render: { fillStyle: "red" }
    });
    const guardedButtonBase = Bodies.rectangle(window.innerWidth - 80, 130, 60, 20, {
      isStatic: true,
      render: { fillStyle: "gray" }
    });
    const guardedExitBlocker = Bodies.rectangle(exitDoor.position.x - 50, exitDoor.position.y - 30, 150, 150, {
      isStatic: true,
      render: { fillStyle: "white" }
    });

    // Add all objects to world
    World.add(world, [
      player, ground, platform, spikes, barrel,
      exitDoor, bbc, buttonTop, buttonBase, 
      fastMovingPlatform, ...interactiveBlocks,
      guardedPlatform, guardingCop, guardedButtonTop, 
      guardedButtonBase, guardedExitBlocker, exitBlocker
    ]);

    // Timer
    let countdown = setInterval(() => {
      timeLeft--;
      timerDisplay.textContent = `Time: ${timeLeft}s`;
      if (timeLeft <= 0) showDeathScreen("Game Over! Time Ran Out!");
    }, 1000);

    // Power-ups
    function giveRandomPowerUp() {
      const powerUps = ["extraJump", "forcefield", "extraTime"];
      const chosen = powerUps[Math.floor(Math.random() * powerUps.length)];
      
      switch(chosen) {
        case "extraJump":
          showPowerUpMessage("Extra Jump!", 4000);
          maxJumpCount = 3;
          break;
          
        case "forcefield":
          showPowerUpMessage("Forcefield!", 8000);
          player.isInvincible = true;
          
          // Create forcefield particles
          forcefieldParticles = [];
          for (let i = 0; i < 20; i++) {
            forcefieldParticles.push({
              angle: Math.random() * Math.PI * 2,
              distance: 35 + Math.random() * 10,
              speed: 0.05 + Math.random() * 0.1
            });
          }
          
          startForcefieldTimer(8);
          break;
          
        case "extraTime":
          showPowerUpMessage("+20 Seconds!", 4000);
          timeLeft += 20;
          break;
      }
    }
    
    function showPowerUpMessage(text, duration) {
      powerUpText.textContent = `Power-Up: ${text}`;
      powerUpText.style.display = "block";
      setTimeout(() => powerUpText.style.display = "none", duration);
    }
    
    function startForcefieldTimer(seconds) {
      forcefieldTimer.textContent = `Forcefield: ${seconds}s`;
      forcefieldTimer.style.display = "block";
      
      const timer = setInterval(() => {
        seconds--;
        forcefieldTimer.textContent = `Forcefield: ${seconds}s`;
        
        if(seconds <= 0) {
          clearInterval(timer);
          forcefieldTimer.style.display = "none";
          player.isInvincible = false;
          forcefieldParticles = [];
        }
      }, 1000);
    }

    // Button system
    let buttonPressed = false;
    let buttonPressCooldown = false;
    let guardedButtonPressed = false;
    let guardedButtonPressCooldown = false;

    function handleButtonPress(buttonTop, buttonBase, exitBlocker) {
      if(buttonPressed || buttonPressCooldown) return;
      
      buttonPressed = true;
      buttonPressCooldown = true;
      
      Body.setPosition(buttonTop, { 
        x: buttonTop.position.x, 
        y: buttonBase.position.y - 5 
      });
      
      World.remove(world, exitBlocker);
      
      setTimeout(() => {
        buttonPressCooldown = false;
      }, 500);
    }

    // Moving platform
    let movingPlatformSpeed = 3;
    function updateMovingPlatform() {
      if(fastMovingPlatform.position.x >= window.innerWidth-300 || fastMovingPlatform.position.x <= 300) {
        movingPlatformSpeed = -movingPlatformSpeed;
      }
      
      Body.translate(fastMovingPlatform, { x: movingPlatformSpeed, y: 0 });
      
      // Move player if standing on platform
      if(Math.abs(player.position.y - fastMovingPlatform.position.y) < 35 &&
         Math.abs(player.position.x - fastMovingPlatform.position.x) < 100 &&
         Math.abs(player.velocity.y) < 1) {
        Body.translate(player, { x: movingPlatformSpeed, y: 0 });
      }
    }

    // Guard patrol
// Define patrol boundaries
const patrolLeft = window.innerWidth - 250; // Left boundary of the platform
const patrolRight = window.innerWidth - 50; // Right boundary of the platform
let guardDirection = 1; // 1 for moving right, -1 for moving left
const copSpeed = 2; // Speed of the cop

function updateGuardingCop() {
  // Define patrol area (left and right bounds relative to guarded platform)
  const patrolLeft = guardedPlatform.position.x - 200;  // 200 pixels left of platform center
  const patrolRight = guardedPlatform.position.x + 100; // 100 pixels right of platform center
  const copSpeed = 2;

  // Change direction at boundaries
  if (guardingCop.position.x <= patrolLeft) {
    guardDirection = 1; // Move right
  } 
  else if (guardingCop.position.x >= patrolRight) {
    guardDirection = -1; // Move left
  }

  // Apply movement
  Body.setVelocity(guardingCop, {
    x: guardDirection * copSpeed,
    y: guardingCop.velocity.y
  });

  // Keep cop properly positioned on platform vertically
  const platformTop = guardedPlatform.position.y - 10; // Platform top surface
  if (guardingCop.position.y > platformTop + 10) { // If cop starts falling
    Body.setPosition(guardingCop, {
      x: guardingCop.position.x,
      y: platformTop - 50 // Position above platform
    });
    Body.setVelocity(guardingCop, { x: guardingCop.velocity.x, y: 0 });
  }
}

    // Player controls
    let keys = {};
    let jumpCount = 0;
    let lastSafePosition = { x: player.position.x, y: player.position.y };
    let isTeleporting = false;
    const safeSurfaces = [ground, platform, fastMovingPlatform, guardedPlatform];

    function handleKeyDown(e) {
      keys[e.code] = true;
      if((e.code === "ArrowUp" || e.code === "KeyW") && jumpCount < maxJumpCount) {
        Body.setVelocity(player, { x: player.velocity.x, y: -12 });
        jumpCount++;
      }
    }

    function handleKeyUp(e) {
      keys[e.code] = false;
    }

    function updatePlayer() {
      if(keys["ArrowLeft"] || keys["KeyA"]) {
        Body.setVelocity(player, { x: -5, y: player.velocity.y });
      }
      if(keys["ArrowRight"] || keys["KeyD"]) {
        Body.setVelocity(player, { x: 5, y: player.velocity.y });
      }
      
      Body.setAngle(player, 0);

      if (!isTeleporting && player.position.y > window.innerHeight + 100) {
        isTeleporting = true;
        setTimeout(() => {
          Body.setPosition(player, lastSafePosition);
          Body.setVelocity(player, { x: 0, y: 0 });
          isTeleporting = false;
        }, 200);
      }
    }

    // Collision detection
    Events.on(engine, "collisionStart", (event) => {
  if (gameOver) return;

  event.pairs.forEach((pair) => {
    const bodies = [pair.bodyA, pair.bodyB];

    // Guarded button press
    if ((bodies.includes(guardedButtonTop) || bodies.includes(guardedButtonBase)) &&
        (bodies.includes(player) || interactiveBlocks.some(block => bodies.includes(block)))) {
      if (!guardedButtonPressed && !guardedButtonPressCooldown) {
        guardedButtonPressed = true;
        guardedButtonPressCooldown = true;

        Body.setPosition(guardedButtonTop, {
          x: guardedButtonTop.position.x,
          y: guardedButtonBase.position.y - 5
        });

        World.remove(world, guardedExitBlocker);

        setTimeout(() => {
          guardedButtonPressCooldown = false;
        }, 500);
      }
    }

    // Check if the player or interactive blocks collide with the buttons
    if (bodies.includes(buttonTop) && 
        (bodies.includes(player) || interactiveBlocks.some(block => bodies.includes(block)))) {
      handleButtonPress(buttonTop, buttonBase, exitBlocker);
    }

    if (bodies.includes(guardedButtonTop) && 
        (bodies.includes(player) || interactiveBlocks.some(block => bodies.includes(block)))) {
      handleButtonPress(guardedButtonTop, guardedButtonBase, guardedExitBlocker);
    }

        if(bodies.includes(player)) {
          // Landing on surfaces
          if(safeSurfaces.some(surface => bodies.includes(surface))) {
            jumpCount = 0;
          }
          
          // Deadly objects
          if(bodies.includes(spikes) || bodies.includes(barrel)) {
            if(!player.isInvincible) showDeathScreen("You hit an obstacle!");
          }
          
          // BBC Coin
          if(bodies.includes(bbc) && !bbcActivated) {
            bbcActivated = true;
            giveRandomPowerUp();
            World.remove(world, bbc);
          }
          
          // Button press
          if(bodies.includes(buttonTop)) {
            handleButtonPress(buttonTop, buttonBase, exitBlocker);
          }
          
          // Guarded button press
          if(bodies.includes(guardedButtonTop)) {
            handleButtonPress(guardedButtonTop, guardedButtonBase, guardedExitBlocker);
          }
          
          // Exit door
          if(bodies.includes(exitDoor)) {
            gameOver = true;
            window.location.href = "level5.html";
          }
          
          // Guard cop
          if(bodies.includes(guardingCop) && !player.isInvincible) {
            showDeathScreen("The guarding cop caught you!");
          }
          
          // Track last safe position
          if(safeSurfaces.includes(pair.bodyA) || safeSurfaces.includes(pair.bodyB)) {
            lastSafePosition = { x: player.position.x, y: player.position.y };
          }
        }
      });
    });

    // Game loop
    Events.on(engine, "beforeUpdate", () => {
      // Update barrel emoji position
      const barrelEmoji = document.getElementById('barrel-emoji');
      if (barrelEmoji) {
        barrelEmoji.style.left = `${barrel.position.x}px`;
        barrelEmoji.style.top = `${barrel.position.y}px`;
      }
      if(gameOver) return;
      
      // Update player state
      if (player.velocity.y > 1) {
        playerState = "falling";
      } else if (player.velocity.y < -1) {
        playerState = "jumping";
      } else if (Math.abs(player.velocity.x) > 0.1) {
        playerState = "walking";
      } else {
        playerState = "idle";
      }

      // Update sprite based on player state
      if (playerState === "idle") {
        animationTimer += 0.016;
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === idle1 ? idle2 : idle1;
          animationTimer = 0;
        }
      } else if (playerState === "walking") {
        animationTimer += 0.016;
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === walk1 ? walk2 : walk1;
          animationTimer = 0;
        }
      } else if (playerState === "jumping") {
        currentSprite = jumpp;
      } else if (playerState === "falling") {
        currentSprite = fall;
      }

      updatePlayer();
      updateMovingPlatform();
      updateGuardingCop();
    });

    // Custom rendering
    Events.on(render, "afterRender", () => {Events.on(render, "afterRender", () => {
  const context = render.context;

// In the afterRender event, REPLACE the current cop drawing code with this:
if (copImage.complete) {
  ctx.save();
  ctx.translate(guardingCop.position.x, guardingCop.position.y);
  
  // Flip based on movement direction
  if (guardingCop.velocity.x < 0) {
    ctx.scale(-1, 1);
  }
  
  // Draw wider cop image (80 width instead of 60)
  const desiredWidth = 180; // Increased from 60
  const aspectRatio = copImage.height / copImage.width;
  const desiredHeight = desiredWidth * aspectRatio;
  
  ctx.drawImage(
    copImage,
    -desiredWidth/2, // Center horizontally
    -desiredHeight/2, // Center vertically
    desiredWidth,
    desiredHeight
  );
  ctx.restore();
}
});
      const ctx = render.context;

      // Draw spikes as grey triangles
      const spikeWidth = 100;
      const spikeHeight = 20;
      const spikeCount = 5;
      const spikeX = spikes.position.x - spikeWidth / 2;
      const spikeY = spikes.position.y - spikeHeight / 2;

      ctx.save();
      ctx.fillStyle = "grey";
      ctx.beginPath();
      for (let i = 0; i < spikeCount; i++) {
        const x = spikeX + (i * spikeWidth) / spikeCount;
        const xMid = x + spikeWidth / (2 * spikeCount);
        const xEnd = x + spikeWidth / spikeCount;
        ctx.moveTo(x, spikeY + spikeHeight);
        ctx.lineTo(xMid, spikeY);
        ctx.lineTo(xEnd, spikeY + spikeHeight);
      }
      ctx.fill();
      ctx.restore();

      // Draw player sprite
      ctx.save();
      ctx.translate(player.position.x, player.position.y);
      if (player.velocity.x < 0) {
        ctx.scale(-1, 1);
      }
      ctx.drawImage(currentSprite, -25, -25, 50, 50);
      ctx.restore();

      // Draw BBC if not collected
      if (!bbcActivated) {
        ctx.save();
        ctx.translate(bbc.position.x, bbc.position.y);
        if (bbcImage.complete) {
          ctx.drawImage(bbcImage, -20, -20, 40, 40);
        } else {
          ctx.beginPath();
          ctx.fillStyle = "yellow";
          ctx.arc(0, 0, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "gold";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        ctx.restore();
      }

      // Draw forcefield if active
      if (player.isInvincible) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.6;
        ctx.arc(player.position.x, player.position.y, 35, 0, 2 * Math.PI);
        ctx.stroke();
        
        // Draw particles
        if (forcefieldParticles.length > 0) {
          forcefieldParticles.forEach(p => {
            p.angle += p.speed;
            const x = player.position.x + Math.cos(p.angle) * p.distance;
            const y = player.position.y + Math.sin(p.angle) * p.distance;
            
            ctx.beginPath();
            ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        ctx.restore();
      }

      // Draw the guarding cop sprite
if (copImage.complete) {
  ctx.save();
  ctx.translate(guardingCop.position.x, guardingCop.position.y);
  if (guardingCop.velocity.x < 0) {
    ctx.scale(-1, 1); // Flip when moving left
  }
  ctx.drawImage(
    copImage,
    -30, // Half of width (60/2)
    -50, // Half of height (100/2)
    60,  // Width matches physics body
    100  // Height matches physics body
  );
  ctx.restore();
}

    });

    // Event listeners
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    // Start the engine
    Engine.run(engine);
    Render.run(render);
  </script>
</body>
</html>