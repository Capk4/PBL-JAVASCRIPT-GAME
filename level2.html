<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Level 2: City</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: url('images/zoo.jpg') no-repeat center center fixed;
      background-size: cover;
    }

    #death-screen {
            position: fixed;
            z-index: 2;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 1000;
            gap: 20px;
            box-sizing: border-box;
            padding: 40px;
        }

        #death-screen h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #FF6347;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.6);
        }
  
        #death-message {
            font-size: 1.8rem;
            margin-bottom: 30px;
            font-family: "Arial", sans-serif;
        }
  
        #death-screen button {
            background-color: #FF6347;
            color: white;
            padding: 15px 40px;
            font-size: 1.5rem;
            border: none;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(255, 99, 71, 0.8);
            transition: transform 0.3s, box-shadow 0.3s;
        }
  
        #death-screen button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 99, 71, 1);
        }
  
        #death-screen button:active {
            transform: scale(1.05);
        }
    
    .game-ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial;
    }
    
    #timer {
      font-size: 24px;
    }
    
    #powerup-text {
      font-size: 20px;
      color: yellow;
      font-weight: bold;
      display: none;
    }
    
    #forcefield-timer {
      font-size: 20px;
      color: cyan;
      font-weight: bold;
      display: none;
    }

    .barrel-emoji {
  position: absolute;
  font-size: 24px;
  pointer-events: none;
  z-index: 10;
  transform: translate(-50%, -50%);
}
  </style>
</head>
<body>
  <div id="death-screen">
    <h2>Game Over!</h2>
    <p id="death-message"></p>
    <button onclick="restartGame()">Retry</button>
  </div>

  <div class="game-ui">
    <div id="timer">Time: 30s</div>
    <div id="powerup-text"></div>
    <div id="forcefield-timer"></div>
  </div>

  <div id="barrel-emoji-1" class="barrel-emoji">ðŸ’€</div>
<div id="barrel-emoji-2" class="barrel-emoji">ðŸ’€</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.14.2/matter.min.js"></script>
  <script>
    const { Engine, Render, World, Bodies, Body, Events } = Matter;
    
    // Game setup
    const engine = Engine.create();
    const world = engine.world;
    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: "transparent",
      }
    });
    
    // Preload player sprites
const idle1 = new Image();
const idle2 = new Image();
const walk1 = new Image();
const walk2 = new Image();
const jumpp = new Image();
const fall = new Image();

idle1.src = "images/idle1.png";
idle2.src = "images/idle2.png";
walk1.src = "images/walk1.png";
walk2.src = "images/walk2.png";
jumpp.src = "images/jumpp.png";
fall.src = "images/fall.png";

// Preload BBC image
const bbcImage = new Image();
bbcImage.src = "images/bbc.png";
bbcImage.onload = () => console.log("BBC image loaded successfully");
bbcImage.onerror = () => {
  console.error("Failed to load BBC image");
  // You could set a flag here to use the circle fallback
};

// Add these variables with your other game state variables
let lastSafePosition = { x: 150, y: window.innerHeight - 80 };
let isTeleporting = false;

    // Game state
    let maxJumpCount = 2;
    let timeLeft = 30;
    let gameOver = false;
    let bbcActivated = false;
    let buttonPressed = false;
    let buttonPressCooldown = false;
    let forcefieldParticles = []; // Array for forcefield particles
    
    let playerState = "idle"; // Possible states: "idle", "walking", "jumping", "falling"
let currentSprite = idle1; // Default sprite
let animationTimer = 0; // Timer for sprite animation

    // UI Elements
    const timerDisplay = document.getElementById("timer");
    const powerUpText = document.getElementById("powerup-text");
    const forcefieldTimer = document.getElementById("forcefield-timer");
    const deathScreen = document.getElementById("death-screen");
    const deathMessage = document.getElementById("death-message");
    
    // ========== GAME OBJECTS ==========
    
    // Player (keep original position)
    const player = Bodies.rectangle(150, window.innerHeight - 80, 50, 50, {
      restitution: 0.2,
      friction: 0.8,
      density: 0.01,
      inertia: Infinity,
      isInvincible: false, // Added for forcefield
      render: { fillStyle: "transparent"}
    });
    
    // Exit Door (keep original position)
    const exitDoor = Bodies.rectangle(window.innerWidth - 810, window.innerHeight - 225, 200, 225, {
      isStatic: true,
      render: { fillStyle: "green" }
    });
    
    // Button System (from Level 1)
    const buttonX = window.innerWidth - 200;
    const buttonBaseY = window.innerHeight - 50;
    const buttonTop = Bodies.rectangle(buttonX, buttonBaseY - 15, 40, 25, {
      isStatic: true,
      render: { fillStyle: "red" }
    });
    const buttonBase = Bodies.rectangle(buttonX, buttonBaseY, 60, 20, {
      isStatic: true,
      render: { fillStyle: "gray" }
    });
    const exitBlocker = Bodies.rectangle(exitDoor.position.x, exitDoor.position.y, 250, 250, {
      isStatic: true,
      render: { fillStyle: "#444", opacity: 0.7 }
    });
    
    // Platforms
    const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight-20, window.innerWidth, 40, {
      isStatic: true,
      render: { fillStyle: "#2a2a2a" }
    });
    
    const platforms = [
      Bodies.rectangle(window.innerWidth*0.3, window.innerHeight-180, 250, 20, { 
        isStatic: true,
        render: { fillStyle: "#5a5a5a" }
      }),
      Bodies.rectangle(window.innerWidth*0.7, window.innerHeight-330, 250, 20, {
        isStatic: true,
        render: { fillStyle: "#5a5a5a" }
      }),
      Bodies.rectangle(window.innerWidth*0.4, window.innerHeight-480, 250, 20, {
        isStatic: true,
        render: { fillStyle: "#5a5a5a" }
      }),
      Bodies.rectangle(window.innerWidth/2, window.innerHeight-600, 200, 20, {
        isStatic: true,
        render: { fillStyle: "orange" },
        label: "movingPlatform"
      })
    ];
    
    // Obstacles
    const spikes = [
      Bodies.rectangle(window.innerWidth*0.2, window.innerHeight-50, 100, 20, {
        isStatic: true,
        render: { fillStyle: "transparent" }
      }),
      Bodies.rectangle(window.innerWidth*0.7, window.innerHeight-350, 100, 20, {
        isStatic: true,
        render: { fillStyle: "transparent" }
      })
    ];
    
    const barrels = [
      Bodies.circle(window.innerWidth*0.5, window.innerHeight-250, 30, {
        restitution: 0.6,
        render: { fillStyle: "red" }
      }),
      Bodies.circle(window.innerWidth*0.6, window.innerHeight-500, 30, {
        restitution: 0.6,
        render: { fillStyle: "red" }
      })
    ];
    
    // BBC Coin
    const bbc = Bodies.circle(window.innerWidth*0.7, window.innerHeight-450, 20, {
      isStatic: true,
      isSensor: true,
      render: { fillStyle: "yellow" }
    });
    
    // Interactive Block
    const box = Bodies.rectangle(500, window.innerHeight-230, 60, 60, {
      restitution: 0.4,
      render: { fillStyle: "lime" }
    });
    
    // Add all objects to world
    World.add(world, [
      player, ground, exitDoor, exitBlocker,
      buttonTop, buttonBase, bbc, box,
      ...platforms, ...spikes, ...barrels
    ]);
    
    // ========== GAME LOGIC ==========
    
    // Timer
    const countdown = setInterval(() => {
      timeLeft--;
      timerDisplay.textContent = `Time: ${timeLeft}s`;
      if (timeLeft <= 0) showDeathScreen("Game Over! Time Ran Out!");
    }, 1000);
    
    // Power-ups
    function giveRandomPowerUp() {
      const powerUps = ["extraJump", "forcefield", "extraTime"];
      const chosen = powerUps[Math.floor(Math.random() * powerUps.length)];
      
      switch(chosen) {
        case "extraJump":
          showPowerUpMessage("Extra Jump!", 4000);
          maxJumpCount = 3;
          break;
          
        case "forcefield":
          showPowerUpMessage("Forcefield!", 8000);
          player.isInvincible = true;
          
          // Create forcefield particles
          forcefieldParticles = [];
          for (let i = 0; i < 20; i++) {
            forcefieldParticles.push({
              angle: Math.random() * Math.PI * 2,
              distance: 35 + Math.random() * 10,
              speed: 0.05 + Math.random() * 0.1
            });
          }
          
          startForcefieldTimer(8);
          break;
          
        case "extraTime":
          showPowerUpMessage("+20 Seconds!", 4000);
          timeLeft += 20;
          break;
      }
    }
    
    function showPowerUpMessage(text, duration) {
      powerUpText.textContent = `Power-Up: ${text}`;
      powerUpText.style.display = "block";
      setTimeout(() => powerUpText.style.display = "none", duration);
    }
    
    function startForcefieldTimer(seconds) {
      forcefieldTimer.textContent = `Forcefield: ${seconds}s`;
      forcefieldTimer.style.display = "block";
      
      const timer = setInterval(() => {
        seconds--;
        forcefieldTimer.textContent = `Forcefield: ${seconds}s`;
        
        if(seconds <= 0) {
          clearInterval(timer);
          forcefieldTimer.style.display = "none";
          player.isInvincible = false;
          forcefieldParticles = []; // Clear particles
        }
      }, 1000);
    }
    
    // Button System
    function handleButtonPress() {
      if(buttonPressed || buttonPressCooldown) return;
      
      buttonPressed = true;
      buttonPressCooldown = true;
      
      // Visual button press
      Body.setPosition(buttonTop, { 
        x: buttonTop.position.x, 
        y: buttonBase.position.y - 5 
      });
      
      // Remove exit blocker
      World.remove(world, exitBlocker);
      
      // Reset button after delay
      setTimeout(() => {
        buttonPressCooldown = false;
      }, 500);
    }
    
    // Moving Platform
    let movingPlatformSpeed = 3;
    function updateMovingPlatform() {
      const platform = platforms.find(p => p.label === "movingPlatform");
      if(!platform) return;
      
      if(platform.position.x >= window.innerWidth-300 || platform.position.x <= 300) {
        movingPlatformSpeed = -movingPlatformSpeed;
      }
      
      Body.translate(platform, { x: movingPlatformSpeed, y: 0 });
      
      // Move player if standing on platform
      if(isOnMovingPlatform(platform)) {
        Body.translate(player, { x: movingPlatformSpeed, y: 0 });
      }
    }
    
    function isOnMovingPlatform(platform) {
      return Math.abs(player.position.y - platform.position.y) < 35 &&
             Math.abs(player.position.x - platform.position.x) < 100;
    }
    
    // Player Controls
    let keys = {};
    let jumpCount = 0;
    
    function handleKeyDown(e) {
      keys[e.code] = true;
      if((e.code === "ArrowUp" || e.code === "KeyW") && jumpCount < maxJumpCount) {
        Body.setVelocity(player, { x: player.velocity.x, y: -12 });
        jumpCount++;
      }
    }
    
    function handleKeyUp(e) {
      keys[e.code] = false;
    }
    
    function updatePlayer() {
      if(keys["ArrowLeft"] || keys["KeyA"]) {
        Body.setVelocity(player, { x: -5, y: player.velocity.y });
      }
      if(keys["ArrowRight"] || keys["KeyD"]) {
        Body.setVelocity(player, { x: 5, y: player.velocity.y });
      }
      
      Body.setAngle(player, 0);
    }
    
    // Collision Detection
    const safeSurfaces = [ground, ...platforms];
    
    Events.on(engine, "collisionStart", (event) => {
      event.pairs.forEach((pair) => {
    if(pair.bodyA === player || pair.bodyB === player) {
      const otherBody = pair.bodyA === player ? pair.bodyB : pair.bodyA;
      
      // Landing on surfaces
      if(safeSurfaces.includes(otherBody)) {
        jumpCount = 0;
        // Update last safe position when landing
        lastSafePosition = { x: player.position.x, y: player.position.y };
      }
          
          // Landing on surfaces
          if(safeSurfaces.includes(otherBody)) {
            jumpCount = 0;
          }
          
          // Deadly objects
          if(spikes.includes(otherBody) || barrels.includes(otherBody)) {
            if(!player.isInvincible) showDeathScreen("You hit an obstacle!");
          }
          
          // BBC Coin
          if(otherBody === bbc && !bbcActivated) {
            bbcActivated = true;
            giveRandomPowerUp();
            World.remove(world, bbc);
          }
          
          // Button press
          if(otherBody === buttonTop) {
            handleButtonPress();
          }
          
          // Exit door
          if(otherBody === exitDoor && !gameOver) {
            gameOver = true;
            window.location.href = "level3.html";
          }
        }
      });
    });
    
    // Game Loop
    Events.on(engine, "beforeUpdate", () => {
      // Update barrel emoji positions
      const barrelEmoji1 = document.getElementById('barrel-emoji-1');
      const barrelEmoji2 = document.getElementById('barrel-emoji-2');
      if (barrelEmoji1 && barrelEmoji2 && barrels.length >= 2) {
        barrelEmoji1.style.left = `${barrels[0].position.x}px`;
        barrelEmoji1.style.top = `${barrels[0].position.y}px`;
        barrelEmoji2.style.left = `${barrels[1].position.x}px`;
        barrelEmoji2.style.top = `${barrels[1].position.y}px`;
      }

      // Update player state
      if (player.velocity.y > 1) {
        playerState = "falling";
      } else if (player.velocity.y < -1) {
        playerState = "jumping";
      } else if (Math.abs(player.velocity.x) > 0.1) {
        playerState = "walking";
      } else {
        playerState = "idle";
      }

      // Update sprite based on player state
      if (playerState === "idle") {
        animationTimer += 0.016; // Increment timer (assuming 60 FPS)
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === idle1 ? idle2 : idle1;
          animationTimer = 0;
        }
      } else if (playerState === "walking") {
        animationTimer += 0.016;
        if (animationTimer > 0.2) {
          currentSprite = currentSprite === walk1 ? walk2 : walk1;
          animationTimer = 0;
        }
      } else if (playerState === "jumping") {
        currentSprite = jumpp;
      } else if (playerState === "falling") {
        currentSprite = fall;
      }

      if(gameOver) return;
        
  // Add this respawn check (same as Level 4)
  if (!isTeleporting && player.position.y > window.innerHeight + 100) {
    isTeleporting = true;
    setTimeout(() => {
      Body.setPosition(player, lastSafePosition);
      Body.setVelocity(player, { x: 0, y: 0 });
      isTeleporting = false;
    }, 200);
  }
  
      updatePlayer();
      updateMovingPlatform();
    });
    
    // Game Management
    function showDeathScreen(message) {
      if(gameOver) return;
      
      gameOver = true;
      deathMessage.textContent = message;
      deathScreen.style.display = "flex";
      clearInterval(countdown);
  
      // Hide barrel emojis
      document.querySelectorAll('.barrel-emoji').forEach(emoji => {
        emoji.style.display = 'none';
      });
    }
    
    function restartGame() {
      document.querySelectorAll('.barrel-emoji').forEach(emoji => {
        emoji.style.display = 'block';
      });
      location.reload();
    }
    
    // Event Listeners
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);
    window.addEventListener("resize", () => {
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      Render.setSize(render, window.innerWidth, window.innerHeight);
    });
    
    // Start the engine
    Engine.run(engine);
    Render.run(render);

    // Custom render function to draw the player sprite and other elements
    Events.on(render, "afterRender", () => {
      const ctx = render.context;

      // Draw spikes as grey triangles
      spikes.forEach(spike => {
        const spikeWidth = 100; // Total width of the spike group
        const spikeHeight = 20; // Height of each spike
        const spikeCount = 5; // Number of triangles
        const spikeX = spike.position.x - spikeWidth / 2; // Start position (centered)
        const spikeY = spike.position.y - spikeHeight / 2;

        ctx.save();
        ctx.fillStyle = "grey"; // Grey color for spikes
        ctx.beginPath();
        for (let i = 0; i < spikeCount; i++) {
          const x = spikeX + (i * spikeWidth) / spikeCount;
          const xMid = x + spikeWidth / (2 * spikeCount);
          const xEnd = x + spikeWidth / spikeCount;

          // Draw a triangle
          ctx.moveTo(x, spikeY + spikeHeight); // Bottom-left corner
          ctx.lineTo(xMid, spikeY); // Top point
          ctx.lineTo(xEnd, spikeY + spikeHeight); // Bottom-right corner
        }
        ctx.fill(); // Fill the triangles with grey
        ctx.restore();
      });

      // Draw the player sprite
      const playerPos = player.position;
      ctx.save();
      ctx.translate(playerPos.x, playerPos.y);
      if (player.velocity.x < 0) {
        ctx.scale(-1, 1); // Flip horizontally if moving left
      }
      ctx.drawImage(currentSprite, -25, -25, 50, 50); // Adjust size to match player dimensions
      ctx.restore();

      // Draw forcefield if active
      if (player.isInvincible) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 4;
        ctx.globalAlpha = 0.6;
        ctx.arc(player.position.x, player.position.y, 35, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Forcefield particle effect
        if (forcefieldParticles.length > 0) {
          ctx.save();
          forcefieldParticles.forEach(p => {
            p.angle += p.speed;
            const x = player.position.x + Math.cos(p.angle) * p.distance;
            const y = player.position.y + Math.sin(p.angle) * p.distance;
            
            ctx.beginPath();
            ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.restore();
        }
        ctx.restore();
      }

      // Draw BBC if it exists and hasn't been collected
      if (bbc && !bbcActivated) {
        ctx.save();
        ctx.translate(bbc.position.x, bbc.position.y);
        
        if (bbcImage.complete) {
          // Draw the image if loaded
          ctx.drawImage(bbcImage, -20, -20, 40, 40);
        } else {
          // Fallback to yellow circle if image not loaded
          ctx.beginPath();
          ctx.fillStyle = "yellow";
          ctx.arc(0, 0, 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "gold";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        ctx.restore();
      }
    });
  </script>
</body>
</html>